#summary How to get started with Otis library
#labels Featured,Phase-Implementation

= Introduction =

This article describes how to get going with Otis. It shows how to configure mappings between types and how to perform the transformations


= Configuring the mappings =

There is more than one way to configure mappings
  * Add metadata to types using attributes
  * Setup transformations in a xml file
  * Custom mapping providers

==Configuration via metadata==
To define transformations via type metadata all you have to do is mark target types and their members with appropriate attributes. To specify that a type is a target type of transformation, mark it with `MapClass` attribute. Then, for every member which will be mapped to source type, specify `Map` attribute. In following example, `UserDTO` is a target type for `UserEntity->UserDTO` transformation.

===Sample===
{{{
// source class for conversion
class UserEntity
{
    public int Id { get ... }
    public string FirstName { get ... }
    public string LastName { get ... }
    public DateTime BirthDate { get ... }
    public IList<ProjectEntity> Projects { get ... }
    public UserEntity Boss { get ... }    
}

// target type for conversion
[MapClass(typeof(UserEntity))] // defines conversion from UserEntity
class UserDTO
{
    [Map]  // maps to the property of same name   
    public int Id { get ... }

    [Map("UserName.ToLower()")]
    public string UserName { get ... }
        [Map("FirstName + \" \" + LastName")] // planned for C# 3.0: [Map( (User u) => u.FirstName + " " + u.LastName; )]
    public string FullName { get ... }

    [Map("BirthDate", Format="Born on {0:D}")] // converts DateTime to string, and formats it as long date
    public string Birthday { get ... }
    
    [Map] // source is an IList<ProjectEntity>, target is array
    public ProjectDTO[] Projects { get ... }  
    
    [Map("Projects.Count")]
    public int ProjectCount { get...} 

    // iterates over all tasks in all projects and calculates average tasks duration
    [Map("avg:Projects/Tasks/Duration")]
    public double AvgTaskDuration { get...} 

    // iterates over all tasks in all projects and returns maximum task duration
    [Map("max:Projects/Tasks/Duration")]
    public int MaxTaskDuration { get...} 
    
    [Map] // recursively maps the Boss property
    public UserDTO Boss { get ... } 
}

// usage
[Test]
public void Test()
{
    Configuration cfg = new Configuration();            // instantiate a new Configuration, one per application is needed
    cfg.AddType(typeof(UserDTO));                       // initialize it using type metadata, but easier is 
                                                        // cfg.AddAssembly(Assembly.GetExecutingAssembly()) to register all types at once
    IAssembler<UserDTO, UserEntity> asm                 // retrieve the assembler
        = cfg.GetAssembler<UserDTO, UserEntity>();
    UserEntity entity = ...                             // retrieve a UserEntity instance from somewhere
    UserDTO dto = asm.AssembleFrom(entity);             // do the transformation
    
    Assert.AreEqual(dto.Id,              entity.Id);
    Assert.AreEqual(dto.UserName,        entity.UserName.ToLower());
    Assert.AreEqual(dto.FullName,        entity.FirstName + " " + entity.LastName);
    Assert.AreEqual(dto.Birthday,        entity.BirthDate.ToString("Born on {0:D}"));
    Assert.AreEqual(dto.Projects.Length, entity.Projects.Count);
    Assert.AreEqual(dto.ProjectCount,    entity.Projects.Count); 
      
    Assert.AreEqual(dto.Boss.Id,         entity.Boss.Id);
    Assert.AreEqual(dto.Boss.UserName,   entity.Boss.UserName.ToLower());
    Assert.AreEqual(dto.Boss.FullName,   entity.Boss.FirstName + " " + entity.LastName);
    
    // calculating max and avg task duration to test the transformation
    int max, cnt, sum;
    
    foreach(Project project in entity.Projects)
        foreach(Task task in project.Tasks)
        {
            cnt++;
            sum = sum + task.Duration; 
            max = task.Duration > max ? task.Duration : max;    
        }    
    double avg = (double)sum / cnt; 
        
    Assert.AreEqual(avg, dto.AvgTaskDuration);
    Assert.AreEqual(max, dto.MaxTaskDuration);        
}
}}}

==Configuration via XML files==
Configuration via XML files makes source code cleaner, and . These files can be standalone files which are deployed with the application, or built into the application as resources.
If you choose this path, target class will look simply like this:

{{{
// target type for conversion
class UserDTO
{
    public int Id { get ... }
    public string UserName { get ... }
    public string FullName { get ... }
    public string Birthday { get ... }
    public ProjectDTO[] Projects { get ... }  
    public int ProjectCount { get...} 
    public double AvgTaskDuration { get...} 
    public int MaxTaskDuration { get...} 
    public UserDTO Boss { get ... } 
}
}}}

The xml mapping looks like this:
{{{
<target name="gen_ddl">
    <exec program="tools\plural\generator.exe" workingdir=".">
        <arg value="-s"/>
        <arg value="-o:src\db\firebird"/>
        <arg value="${model}"/>
    </exec>
</target>
}}}